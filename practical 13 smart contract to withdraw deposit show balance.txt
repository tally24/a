
public class QuickSortAnalysis {

    public static void main(String[] args) {
        // Create an array of random numbers
        int[] numbers = new int[10000];
        Random rand = new Random();
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = rand.nextInt();
        }

        // Run the deterministic quick sort algorithm
        long deterministicTime = System.currentTimeMillis();
        deterministicQuickSort(numbers, 0, numbers.length - 1);
        long deterministicTimeEnd = System.currentTimeMillis();

        // Run the randomized quick sort algorithm
        long randomizedTime = System.currentTimeMillis();
        randomizedQuickSort(numbers, 0, numbers.length - 1);
        long randomizedTimeEnd = System.currentTimeMillis();

        // Print the running times of the two algorithms
        System.out.println("Deterministic quick sort time: " + (deterministicTimeEnd - deterministicTime));
        System.out.println("Randomized quick sort time: " + (randomizedTimeEnd - randomizedTime));
    }

    public static void deterministicQuickSort(int[] numbers, int left, int right) {
        // If the array is empty or has only one element, return
        if (left >= right) {
            return;
        }

        // Choose the pivot element as the median of the array
        int pivot = numbers[(left + right) / 2];

        // Partition the array around the pivot
        int partition = partition(numbers, left, right, pivot);

        // Recursively sort the left and right subarrays
        deterministicQuickSort(numbers, left, partition - 1);
        deterministicQuickSort(numbers, partition + 1, right);
    }

    public static void randomizedQuickSort(int[] numbers, int left, int right) {
        // If the array is empty or has only one element, return
        if (left >= right) {
            return;
        }

        // Choose the pivot element as a random element from the array
        int pivotIndex = rand.nextInt(right - left + 1) + left;
        int pivot = numbers[pivotIndex];

        // Swap the pivot element with the rightmost element
        swap(numbers, pivotIndex, right);

        // Partition the array around the pivot
        int partition = partition(numbers, left, right, pivot);

        // Recursively sort the left and right subarrays
        randomizedQuickSort(numbers, left, partition - 1);
        randomizedQuickSort(numbers, partition + 1, right);
    }

    public static int partition(int[] numbers, int left, int right, int pivot) {
        // Initialize the pointers to the left and right elements of the subarray
        int i = left;
        int j = right - 1;

        // Loop until the pointers meet
        while (i <= j) {
            // Find the first element on the right that is smaller than the pivot
            while (i <= j && numbers[j] > pivot) {
                j--;
            }

            // Find the first element on the left that is greater than the pivot
            while (i <= j && numbers[i] < pivot) {
                i++;
            }

            // If the pointers have not met, swap the elements at those positions
            if (i <= j) {
                swap(numbers, i, j);
                i++;
                j--;
            }
        }

        // Return the index of the element at the end of the subarray
        return i;
    }

    public static void swap(int[] numbers, int i, int j) {
        // Store the element at index i in a temporary variable
        int temp = numbers[i];

        // Move the element at index j to index i
        numbers[i] = numbers[j];

        // Move the element at index i to index j
        numbers[j] = temp;
    }
}